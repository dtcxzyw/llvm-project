// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --check-globals all --version 5
// RUN: %clang_cc1 -triple x86_64-linux-gnu -Wno-pmf-conversions %s -O3 -emit-llvm -o - | FileCheck %s

struct A {
  int data;
//.
// CHECK: @method = local_unnamed_addr global ptr @_ZN1A6methodEv, align 8
//.
// CHECK-LABEL: define linkonce_odr noundef i32 @_ZN1A6methodEv(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(12) [[THIS:%.*]]) #[[ATTR0:[0-9]+]] comdat align 2 {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    ret i32 0
//
  int method() { return 0; }
  virtual int virtual_method() { return 1; }
  virtual ~A() = default;
};

struct C {
  int data;
};

struct B : C, A {
  virtual int virtual_method() override { return 2; }
};

using pmf_type = int (A::*)();
using pf_type = int (*)(A*);

pf_type method = reinterpret_cast<pf_type>(&A::method);

// CHECK-LABEL: define dso_local noundef ptr @_Z11convert_pmfP1AMS_FivE(
// CHECK-SAME: ptr noundef readonly captures(none) [[P:%.*]], i64 [[METHOD_COERCE0:%.*]], i64 [[METHOD_COERCE1:%.*]]) local_unnamed_addr #[[ATTR1:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[TMP0:%.*]] = and i64 [[METHOD_COERCE0]], 1
// CHECK-NEXT:    [[MEMPTR_ISVIRTUAL_NOT:%.*]] = icmp eq i64 [[TMP0]], 0
// CHECK-NEXT:    br i1 [[MEMPTR_ISVIRTUAL_NOT]], label %[[MEMPTR_NONVIRTUAL:.*]], label %[[MEMPTR_VIRTUAL:.*]]
// CHECK:       [[MEMPTR_VIRTUAL]]:
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 [[METHOD_COERCE1]]
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP1]], align 8, !tbaa [[TBAA2:![0-9]+]]
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[VTABLE]], i64 [[METHOD_COERCE0]]
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[TMP2]], i64 -1
// CHECK-NEXT:    [[MEMPTR_VIRTUALFN:%.*]] = load ptr, ptr [[TMP3]], align 8, !nosanitize [[META5:![0-9]+]]
// CHECK-NEXT:    br label %[[MEMPTR_END:.*]]
// CHECK:       [[MEMPTR_NONVIRTUAL]]:
// CHECK-NEXT:    [[MEMPTR_NONVIRTUALFN:%.*]] = inttoptr i64 [[METHOD_COERCE0]] to ptr
// CHECK-NEXT:    br label %[[MEMPTR_END]]
// CHECK:       [[MEMPTR_END]]:
// CHECK-NEXT:    [[TMP4:%.*]] = phi ptr [ [[MEMPTR_VIRTUALFN]], %[[MEMPTR_VIRTUAL]] ], [ [[MEMPTR_NONVIRTUALFN]], %[[MEMPTR_NONVIRTUAL]] ]
// CHECK-NEXT:    ret ptr [[TMP4]]
//
pf_type convert_pmf(A* p, pmf_type method) {
  return reinterpret_cast<pf_type>(p->*method);
}

// CHECK-LABEL: define dso_local noundef nonnull ptr @_Z17convert_pmf_constP1A(
// CHECK-SAME: ptr noundef readnone captures(none) [[P:%.*]]) local_unnamed_addr #[[ATTR2:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    ret ptr @_ZN1A6methodEv
//
pf_type convert_pmf_const(A* p) {
  return reinterpret_cast<pf_type>(p->*(&A::method));
}

// CHECK-LABEL: define dso_local noundef ptr @_Z18convert_vpmf_constP1A(
// CHECK-SAME: ptr noundef readonly captures(none) [[P:%.*]]) local_unnamed_addr #[[ATTR1]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[P]], align 8, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[MEMPTR_VIRTUALFN:%.*]] = load ptr, ptr [[VTABLE]], align 8, !nosanitize [[META5]]
// CHECK-NEXT:    ret ptr [[MEMPTR_VIRTUALFN]]
//
pf_type convert_vpmf_const(A* p) {
  return reinterpret_cast<pf_type>(p->*(&A::virtual_method));
}

// CHECK-LABEL: define dso_local noundef range(i32 0, 2) i32 @_Z21call_b_virtual_methodP1B(
// CHECK-SAME: ptr noundef [[P:%.*]]) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[VTABLE_I:%.*]] = load ptr, ptr [[P]], align 8, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[MEMPTR_VIRTUALFN_I:%.*]] = load ptr, ptr [[VTABLE_I]], align 8, !nosanitize [[META5]]
// CHECK-NEXT:    [[CALL1:%.*]] = tail call noundef i32 [[MEMPTR_VIRTUALFN_I]](ptr noundef nonnull [[P]]) #[[ATTR3:[0-9]+]]
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[P]], align 8, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[VTABLE]], align 8
// CHECK-NEXT:    [[CALL2:%.*]] = tail call noundef i32 [[TMP0]](ptr noundef nonnull align 8 dereferenceable(16) [[P]]) #[[ATTR3]]
// CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[CALL1]], [[CALL2]]
// CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
// CHECK-NEXT:    ret i32 [[CONV]]
//
int call_b_virtual_method(B* p) {
  return convert_pmf(p, &A::virtual_method)(p) == p->virtual_method();
}

//.
// CHECK: attributes #[[ATTR0]] = { mustprogress nounwind "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+cx8,+mmx,+sse,+sse2,+x87" }
// CHECK: attributes #[[ATTR1]] = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+cx8,+mmx,+sse,+sse2,+x87" }
// CHECK: attributes #[[ATTR2]] = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+cx8,+mmx,+sse,+sse2,+x87" }
// CHECK: attributes #[[ATTR3]] = { nounwind }
//.
// CHECK: [[META0:![0-9]+]] = !{i32 1, !"wchar_size", i32 4}
// CHECK: [[META1:![0-9]+]] = !{!"{{.*}}clang version {{.*}}"}
// CHECK: [[TBAA2]] = !{[[META3:![0-9]+]], [[META3]], i64 0}
// CHECK: [[META3]] = !{!"vtable pointer", [[META4:![0-9]+]], i64 0}
// CHECK: [[META4]] = !{!"Simple C++ TBAA"}
// CHECK: [[META5]] = !{}
//.
